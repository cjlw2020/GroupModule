---
date: "11/22/2019"
title: "Group Module"
author: Clint Lockwood, 
output: 
  html_document:
    theme: cosmo
    toc: true
    toc_float: true
---

***

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	comment = "##",
	prompt = FALSE,
	tidy = TRUE,
	tidy.opts = list(width.cutoff = 75),
	fig.path = "img/"
)
```

Within GIS there are multiple different tools to help you understand data that you collect about different landscapes. From previous modules you would have seen how to create maps to display your statistical analysis, or have seen how to identify different clusters and analyze significant hot and cold spots. Here we will explore how to take Lidar data files to create maps that help you analyze the landscape and interpret it to answer important questions. 
Lidar stands for Light Detection and Ranging. It is a surveying/remote sensing method that measures distance to a target. It does this by illuminating the target with laser light and measuring the reflected light with a sensor. Differences in laser return times and wavelengths can then be used to make digital 3-D representations. It is commonly used to make high-resolution maps, with applications in fields such as archaeology, geography, and laser guidance. 
By being able to analyze landscapes using Lidar, we can answer more important/pertinent questions to current issues. One example of this is Boston's pledge to being carbon neutral by 2050. While this falls under being a civil engineering problem, its an excellent example of a different but important application of GIS, specifically Lidar uses. 
One way that Boston can push towards being carbon neutral would be by switching to renewable energy sources like solar, wind, and hydrologic power. The best places to utilize solar power, for example, would be places that have constant uninterrupted exposure to sunlight. Using Lidar data to map out the rooftops of Boston, we would be able to determine how much solar radiation we can obtain. You would accomplish this by mapping out the rooftops and overlaying a solar radiation layer (another built in-tool). This would in turn help to determine if there would be enough watt hours over the course of a year for it to be beneficial to begin transitioning the majority, if not all, of Boston's rooftops to being solar paneled. 
info & data download here:
https://drive.google.com/file/d/15Tdl4O4dje-7dQgGUciQpTgUza8LUo7Q/view


#Import LIDAR data
##Download packages "lidR" and "raster"
```{r eval=FALSE}
#install.packages("lidR")
library(lidR) #this one for sure
library(sf)
library(ggplot2)
#library(raster)
#ibrary(rgeos)
#library(mapview)
```

#Get Raw LIDAR data into R
##raw LIDAR data
The way LIDAR works is by emitting laser pulses to reflect from objects both on and above the ground surface: vegetation, buildings, bridges, etc. Any emitted laser pulse that encounters multiple reflection surfaces as it travels toward the ground is split into as many returns as there are reflective surfaces.

- The first returned laser pulse is the most significant return and will be associated with the highest feature in the landscape like a treetop or the top of a building. The first return can also represent the ground, in which case only one return will be detected by the lidar system.

- Multiple returns are capable of detecting the elevations of several objects within the laser footprint of an outgoing laser pulse. The intermediate returns, in general, are used for vegetation structure, and the last return for bare-earth terrain models.

- The last return will not always be from a ground return. For example, consider a case where a pulse hits a thick branch on its way to the ground and the pulse does not actually reach the ground. In this case, the last return is not from the ground but from the branch that reflected the entire laser pulse. 

<br><center>
<img src="img/LIDAR_returns_graphic.png" style="border:3px solid black" width="500px"/>
</center><br>

##lidR package function**

```{r eval=FALSE}
setwd("C:/Users/clint/Desktop/Lab4_Data")
las1 <- readLAS("USGS_LPC_MA_Sndy_CMPG_2013_19TCG255905_LAS_2015.las")
las2 <- readLAS("USGS_LPC_MA_Sndy_CMPG_2013_19TCG270905_LAS_2015.las")
#nk:
#las1 <- readLAS("~/Downloads/Lab4_Data/USGS_LPC_MA_Sndy_CMPG_2013_19TCG255905_LAS_2015/USGS_LPC_MA_Sndy_CMPG_2013_19TCG255905_LAS_2015.las")
#las2 <- readLAS("~/Downloads/Lab4_Data/USGS_LPC_MA_Sndy_CMPG_2013_19TCG270905_LAS_2015/USGS_LPC_MA_Sndy_CMPG_2013_19TCG270905_LAS_2015.las")

# Uses the raster package to combine raster images
las <- rbind(las1, las2)
plot(las) #30 seconds
```
#Transition LIDAR data to DEM*

#What is DEM? Why do we need it?*
DEM stands for Digital Elevation Model. This is a 3D CG representation of a terrain's surface created from a terrain's elevation data. Things like power lines, buildings and towers or trees and other vegetation aren't included in the model. It filters out what are known as "non-ground points". Another way to think of it is an image containing only the topography from the ground 
```{r eval=FALSE}
dem <-  grid_terrain(las, algorithm = tin())
plot(dem) # 1.5 min
```
#Convert to DSM + create hillshade model
##What is DSM? Why do we need it?
DSM stands for Digital Surface Model. Unlike the DEM, the DSM DOES include man-made/built and natural points of reference into its representation. Another way to think of it is an image including the first return information.
##What is hillshade? Why do we need it? How is it made?
```{r eval=FALSE}
proj4string(las) <-CRS("+proj=utm +zone=19 +datum=NAD83") #assigning coord ref system
dsm1 <- grid_canopy(las, res = 1, dsmtin())
col <- height.colors(100) #how many colors to use, the more colors the better resolution in the plot
plot(dsm1, col = col)
```
#Elaborate Hillshade. What is it? How is is made?*
```{r eval=FALSE}
slope  <- terrain(dsm1, opt='slope')
aspect <- terrain(dsm1, opt='aspect')
hill <- hillShade(slope, aspect, 45, 120)
plot(hill, col=grey(0:100/100), legend=FALSE, main='Boston University')
plot(dsm1, col=rainbow(25, alpha=0.35),add=TRUE) # 2 min
```

#Add Boston Univeristy rooftop shapefile
#Elaborate shapefile description*
```{r eval = FALSE}
BU_buildings_shp <- st_read("building_structures_bu.shp")
BU_buildings <- ggplot() + 
  geom_sf(data = BU_buildings_shp, size = 0.5, color = "black", fill = "cyan1") + 
  ggtitle("BU Buildings") + 
  coord_sf()
plot(BU_buildings) # 5 sec
```

#Plot Building Vector File on Raster
```{r eval = FALSE}
#This projects the BU rooftop shape file correctly with the hillshade raster image
dsm2 <- projectRaster(dsm1, crs = crs(BU_buildings))
dsm3 <- crop(dsm2, BU_buildings) #there are 16 different options instead of "2" here, not sure which one we want

hill2 <- projectRaster(hill, crs = crs(BU_buildings))
hill3 <- crop(hill2, BU_buildings) #there are 16 different options instead of "2" here, not sure which one we want

plot(hill3, col=grey(0:100/100), legend=FALSE, main ='Boston University')
plot(BU_buildings,add=TRUE)
plot(dsm3,col=rainbow(25, alpha=0.35),add=TRUE) # 30 sec
```




#Outdated script
#Get a processed DSM file into R
```{r eval=FALSE}
dsm <- raster("bu_dsm.tif")
plot(dsm)
```
#Create a hillshade from DSM
```{r eval=FALSE}
slope  <- terrain(dsm, opt='slope')
aspect <- terrain(dsm, opt='aspect')
hill <- hillShade(slope, aspect, 45, 120)
quartz()
plot(hill, col=grey(0:100/100), legend=FALSE, main='Boston University')
plot(dsm1, col=rainbow(25, alpha=0.35), add=TRUE)
```
#unaligned raster + vector file
```{r eval=FALSE}
plot(hill, col=grey(0:100/100), legend=FALSE, main ='Boston University')
plot(BU_buildings,
     add = TRUE)
plot(dsm1, col=rainbow(25, alpha=0.35), add=TRUE)
```



