---
title: "Lidar data in R"
author: "Clint Lockwood, Nicola Kriefall, Ena Miculinic"
date: "11/22/2019"
output:
  html_document:
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---


# Part I. Intro to Lidar

Within GIS there are multiple different tools to help you understand data that you collect about different landscapes. From previous modules you would have seen how to create maps to display your statistical analysis, or have seen how to identify different clusters and analyze significant hot and cold spots. Here we will explore how to take Lidar data files to create maps that help you analyze the landscape and interpret it to answer important questions. 
Lidar stands for Light Detection and Ranging. It is a surveying/remote sensing method that measures distance to a target. It does this by illuminating the target with laser light and measuring the reflected light with a sensor. Differences in laser return times and wavelengths can then be used to make digital 3-D representations. It is commonly used to make high-resolution maps, with applications in fields such as archaeology, geography, and laser guidance. 
By being able to analyze landscapes using Lidar, we can answer more important/pertinent questions to current issues. One example of this is Boston's pledge to being carbon neutral by 2050. While this falls under being a civil engineering problem, its an excellent example of a different but important application of GIS, specifically Lidar uses. 
One way that Boston can push towards being carbon neutral would be by switching to renewable energy sources like solar, wind, and hydrologic power. The best places to utilize solar power, for example, would be places that have constant uninterrupted exposure to sunlight. Using Lidar data to map out the rooftops of Boston, we would be able to determine how much solar radiation we can obtain. You would accomplish this by mapping out the rooftops and overlaying a solar radiation layer (another built in-tool). This would in turn help to determine if there would be enough watt hours over the course of a year for it to be beneficial to begin transitioning the majority, if not all, of Boston's rooftops to being solar paneled. 
info & data download here:
https://drive.google.com/file/d/15Tdl4O4dje-7dQgGUciQpTgUza8LUo7Q/view

## Import LIDAR data

Download packages

```{r eval=FALSE}
#install.packages(c("lidR","sf","ggplot2)
library(lidR) #this one for sure
library(sf)
library(ggplot2)
```

## Get Raw LIDAR data into R

The way LIDAR works is by emitting laser pulses to reflect from objects both on and above the ground surface: vegetation, buildings, bridges, etc. Any emitted laser pulse that encounters multiple reflection surfaces as it travels toward the ground is split into as many returns as there are reflective surfaces.

- The first returned laser pulse is the most significant return and will be associated with the highest feature in the landscape like a treetop or the top of a building. The first return can also represent the ground, in which case only one return will be detected by the lidar system.

- Multiple returns are capable of detecting the elevations of several objects within the laser footprint of an outgoing laser pulse. The intermediate returns, in general, are used for vegetation structure, and the last return for bare-earth terrain models.

- The last return will not always be from a ground return. For example, consider a case where a pulse hits a thick branch on its way to the ground and the pulse does not actually reach the ground. In this case, the last return is not from the ground but from the branch that reflected the entire laser pulse. 

<br><center>
<img src="AN597 Pics/LIDAR_returns_graphic.png" style="border:3px solid black" width="500px"/>
</center><br>

## Reading in LAS data

```{r eval=FALSE}
setwd("C:/Users/clint/Desktop/Lab4_Data")
las1 <- readLAS("USGS_LPC_MA_Sndy_CMPG_2013_19TCG255905_LAS_2015.las")
las2 <- readLAS("USGS_LPC_MA_Sndy_CMPG_2013_19TCG270905_LAS_2015.las")

# Uses the raster package to combine raster images
las <- rbind(las1, las2)
plot(las) #30 seconds
```

## Transition LIDAR data to DEM*

### What is DEM? Why do we need it?*

DEM stands for Digital Elevation Model. This is a 3D CG representation of a terrain's surface created from a terrain's elevation data. Things like power lines, buildings and towers or trees and other vegetation aren't included in the model. It filters out what are known as "non-ground points". Another way to think of it is an image containing only the topography from the ground 

```{r eval=FALSE}
dem <-  grid_terrain(las, algorithm = tin())
plot(dem) # 1.5 min
```

![](AN597 Pics/DEM.png)

## Convert to DSM + create hillshade model

### What is DSM? Why do we need it?

DSM stands for Digital Surface Model. Unlike the DEM, the DSM DOES include man-made/built and natural points of reference into its representation. Another way to think of it is an image including the first return information.

### What is hillshade? Why do we need it? How is it made?
```{r eval=FALSE}
proj4string(las) <-CRS("+proj=utm +zone=19 +datum=NAD83") #assigning coord ref system
dsm1 <- grid_canopy(las, res = 1, dsmtin())
col <- height.colors(100) #how many colors to use, the more colors the better resolution in the plot
plot(dsm1, col = col)
```
#Elaborate Hillshade. What is it? How is is made?*
```{r eval=FALSE}
slope  <- terrain(dsm1, opt='slope')
aspect <- terrain(dsm1, opt='aspect')
hill <- hillShade(slope, aspect, 45, 120)
plot(hill, col=grey(0:100/100), legend=FALSE, main='Boston University')
plot(dsm1, col=rainbow(25, alpha=0.35),add=TRUE) # 2 min
```

![](AN597 Pics/Hillshade2.0.png)

#Add Boston Univeristy rooftop shapefile
#Elaborate shapefile description*
```{r eval = FALSE}
BU_buildings_shp <- st_read("building_structures_bu.shp")
BU_buildings <- ggplot() + 
  geom_sf(data = BU_buildings_shp, size = 0.5, color = "black", fill = "cyan1") + 
  ggtitle("BU Buildings") + 
  coord_sf()
plot(BU_buildings) # 5 sec
```

![](AN597 Pics/BU rooftop shapes.png)

#Plot Building Vector File on Raster
```{r eval = FALSE}
#This projects the BU rooftop shape file correctly with the hillshade raster image
dsm2 <- projectRaster(dsm1, crs = crs(BU_buildings))
dsm3 <- crop(dsm2, BU_buildings) #there are 16 different options instead of "2" here, not sure which one we want

hill2 <- projectRaster(hill, crs = crs(BU_buildings))
hill3 <- crop(hill2, BU_buildings) #there are 16 different options instead of "2" here, not sure which one we want

plot(hill3, col=grey(0:100/100), legend=FALSE, main ='Boston University')
plot(BU_buildings,add=TRUE)
plot(dsm3,col=rainbow(25, alpha=0.35),add=TRUE) # 30 sec
```

![](AN597 Pics/Boston university (shape on DSM).png)

# Part II. How do Boston Common & Arnold Arboretum canopy heights differ?

Lidar data can be downloaded at this [USGS site](https://viewer.nationalmap.gov/basic/)

![](AN597 Pics/alllidar.png)

I downloaded the data from the tiles where "Boston Common" & "Arnold Arboretum" were located. Boston Common was split across two tiles so I downloaded two & combine them below:

```{r eval = FALSE}
#reading in the las data
las.bc1 <- readLAS("~/Downloads/temp/USGS_LPC_MA_Sndy_CMPG_2013_19TCG285905_LAS_2015.las")
las.bc2 <- readLAS("~/Downloads/temp/USGS_LPC_MA_Sndy_CMPG_2013_19TCG300905_LAS_2015.las")

#taking a look - Xquartz pops up
plot(las.bc1)
plot(las.bc2)

#combining the two Boston Common tiles
las.bc <- rbind(las.bc1, las.bc2)
plot(las.bc)
```

![](AN597 Pics/totalbostoncommon.png)

```{r eval = FALSE}
#assigning coordinate reference system - very important
proj4string(las.bc) <- CRS("+proj=utm +zone=19 +datum=NAD83")

#looking at the canopy height model
chm.bc <- grid_canopy(las.bc, res = 1, dsmtin())
plot(chm.bc)
```

![](AN597 Pics/chm.bc.png)

Now I'm going to clip the giant LAS file down to an area of interest within Boston Common with no trees, using the x, y coordinates seen in the canopy height model above.

```{r eval = FALSE}
las.bc.clipped <- lasclipRectangle(las.bc, 329500, 4690980, 329900, 4691380)
plot(las.bc.clipped) #check to see how it looks
```

![](AN597 Pics/chm.bc.clipped.png)

Now to compute the CHM for the clipped area

```{r eval = FALSE}
dsm.bc <- grid_canopy(las.bc.clipped, res = 1, dsmtin())
plot(dsm.bc)
extent(dsm.bc) #400 x 400 area
```

Then I repeated everything above but for a tile of the same size within Arnold Arboretum

```{r eval = FALSE}
las.aa <- readLAS("~/Downloads/temp/USGS_LPC_MA_Sndy_CMPG_2013_19TCG240845_LAS_2015.las")
plot(las.aa)
extent(las.aa)
proj4string(las.aa) <- CRS("+proj=utm +zone=19 +datum=NAD83")

las.aa.clipped <- lasclipRectangle(las.aa, 324650, 4684800, 325050, 4685200)
plot(las.aa.clipped)

chm.aa <- grid_canopy(las.aa.clipped, res = 1, dsmtin())
plot(chm.aa)
extent(chm.aa) #400 x 400
```

![](AN597 Pics/chm.aa.png)

Then we converted the RasterLayer dataset to a data frame so we can do some stats.

```{r eval = FALSE}
df.bc <- as.data.frame(chm.bc, xy = TRUE)

ggplot() +
  geom_raster(data = df.bc , aes(x = x, y = y, fill = Z)) +
  scale_fill_viridis_c()
```

![](AN597 Pics/bc.df.png)

Now for Arnold Arboreteum

```{r eval = FALSE}
df.aa <- as.data.frame(chm.aa, xy = TRUE)

ggplot() +
  geom_raster(data = df.aa, aes(x = x, y = y, fill = Z)) +
  scale_fill_viridis_c()
```

![](AN597 Pics/aa.df.png)

Now grouping the data together & making a new variable called 'site' to distinguish the two.

```{r eval = FALSE}
df.bc$site <- rep("Boston Common",160000)
df.aa$site <- rep("Arnold Arboretum",160000)

site.df <- rbind(df.bc,df.aa)
str(site.df)

ggplot(site.df,aes(x=site,y=Z,color=site))+
  geom_boxplot()+
  ylab("Canopy height (m)")+
  xlab("Site")+
  theme_classic()+
  theme(legend.position="none")+
  scale_color_manual(values=c("chartreuse3","darkgreen"))
```

![](AN597 Pics/plotbysite.png)

Last but not least, the stats. Unfortunately the data is not at all normally distributed.

```{r eval = FALSE}
hist(df.bc$Z)
hist(df.aa$Z)
```

![](AN597 Pics/hist.bc.png)
![](AN597 Pics/hist.aa.png)

We tried normalizing but didn't really trust the results, so we went with a non-parametric test, the Mann-Whitney-Wilcoxon test because we have two independent groups.

``` {r eval = FALSE}
wilcox.test(Z~site,data=site.df)
```

![](AN597 Pics/stats.png)


